getStack() {
  stackdepth="${#BASH_SOURCE[@]}"
  local level

 # case $1 in
 #   1) level=5
 #   2)
 #   3)
 #   4)
 #   5)
 # esac

  for (( var=5; var < $stackdepth; var++ )) do
    printf "%s " "[${BASH_SOURCE[$var]} => ${FUNCNAME[$var]}: ${BASH_LINENO[(($var-1))]}]"
    #"${var}lev"=("${var}lev")
  done
  # echo "[$( caller )] $*" >&2
  # echo "BASH_SOURCE: ${BASH_SOURCE[*]}"
  # echo "BASH_LINENO: ${BASH_LINENO[*]}"
  # echo "FUNCNAME: ${FUNCNAME[*]}"
}

ini() {
  shopt -s dotglob
}

showcolors() {
#- Title:               showcolors
#- Creation Date:       10-03-2015
#- Author:              ---
#- Source:              http://linuxcommand.org/lc3_adv_tput.php
#- Version:             1.0    
#
#: Usage:               showcolors [] 
#: Description:         Uses the setaf and setab capabilities to display the
#:                      available foreground/background color combinations
#: 

  source ~/.functions

  local OPTIND

  while getopts ":hc" opt; do
    case $opt in
      h) printusage -H && return 0        ;;
      c) printusage -C && return 0        ;;
      *) printusage -H >&2 && return 1    ;;
    esac
  done
  shift $(( OPTIND - 1))

  [[ $# -ne 0 ]] && printusage -H >&2 && return 1

  for fg_color in {0..7}; do
    set_foreground=$(tput setaf $fg_color)
    for bg_color in {0..7}; do
      set_background=$(tput setab $bg_color)
      echo -n $set_background$set_foreground
      printf ' F:%s B:%s ' $fg_color $bg_color
    done
    echo $(tput sgr0)
  done
} 

getYesNo() {
#
# NAME
#    GetYesNo - ask a yes or no question
#
# SYNOPSIS
#    GetYesNo "message"
#
# DESCRIPTION
#    This function will prompt the user with the
#    message and wait for the user to answer "yes" or
#    "no".  This function will return true (0) if the
#    user answers yes; otherwise, it will return
#    false (1).
#
#    This function will accept y, yes, n, or no, and it
#    is reasonably tolerant of upper and lower case
#    letters; any other answer will cause the question
#    to be repeated.
#
  _ANSWER=            # Answer read from user

  if [ $# -eq 0 ]; then
    echo "Usage: GetYesNo message" >&2
    exit 1
  fi

  while :
  do
    if [ "$( echo -n )" = "-n" ]; then
      echo "$@\c"
    else
      echo -n "$@"
    fi
    read _ANSWER
    case "$_ANSWER" in
      [yY] | yes | YES | Yes ) return 0       ;;
      [nN] | no  | NO  | No  ) return 1       ;;
      * ) echo "Please enter y or n."         ;;
    esac
  done
}

nameAlreadyUsed() {
#
#- Title:               nameAlreadyUsed
#- Creation Date:       09-27-2015
#- Author:              jeanmichecote
#- Github:              EDIT HERE
#- Version:             1.0    
#
#: Usage:               nameAlreadyUsed [OPTIONS] <arguments>
#: Description:         Verifies if the name entered as second argument exists
#:                      in the directory path entered as first argument
#: Options:             
#:                 -h   Prints out this usage block
#:                 -c   Prints out this function's credentials
#:                 -f   Searches for a function name.
#:                      If this flag is up, no path should be entered as first
#:                      argument but rather only the name of the function.
#: Arguments:       
#:                 $1   Path to search
#:                 $2   Name to target
#: 
#: (exemple):           nameAlreadyUsed "path/to/dir/" "newname"
#:                      nameAlreadyUsed -f funcname
#

  local dest name nameUsed OPTIND

  dest="$1"
  name="$2"

  [[ "$#" -ne 2 ]] && printusage -H >&2 && return 1

  while getopts ":hcf" opt; do
    case $opt in
      h)  printusage -H && return 0      ;;
      c)  printusage -C && return 0      ;;
      f)  nameUsed=$( grep "$name" <(funx) )
          if [[ -n "$nameUsed" ]]; then
            msg_alert "This function name is already used. Please choose another one."
            sleep 1.5
            funx "$name"
            exit 1
          fi
      ;;
      *) printusage -H >&2 && return 1  ;;
    esac
  done
  shift $(( OPTIND - 1))

  shopt -s dotglob
  if [[ -f "${dest}/${name}" ]]; then
    msg_alert "The name chosen for your new script is already used. Please choose another name."
    exit 1
  fi
} 

errX() {
#- Title:               errX   
#- Creation Date:       09-27-2015
#- Author:              jeanmichecote
#- Github:              EDIT HERE
#- Version:             1.0   
# 
#: Usage:               errX [OPTIONS] <arguments>
#: Description:         Prints out a custom error message and 
#:                      exits the script or function
#: Options:             
#:                 -h   Prints out this usage block
#:                 -c   Prints out this function's credentials
#:                 -f   Switches from default script to function
#: Arguments:       
#:                 $1   Message to print out
#: 
#: (exemple):           errX -f "$LINENO: An error has occurred."

  source ~/.functions

  local OPTIND
  scriptname="${0##*/}"
  funcname="${FUNCNAME[1]}"
  # Styles
  RED="\033[0;31m"
  REDB="\033[1;31m"
  BOLD="\033[1;32m" 
  UND="\033[4;32m"  
  NC="\033[0m" # No Color

  while getopts ":hcf" opt; do
    case $opt in
      h) printusage -H && return 0                                    ;;
      c) printusage -C && return 0                                    ;;
      f) echo "${funcname}: ${1:-"Unknown Error"}" >&2 && return 1    ;;
      *) printusage -H >&2 && return 1                                ;;
    esac
  done
  shift $(( OPTIND - 1))

  #echo -e "${BOLD}${scriptname}${NC}: ${RED}${1:-"Unknown Error"}${NC}" >&2 && exit 1
  msg_alert "${1:-"Unknown Error"}" >&2 && exit 1
  
  [[ $# -ne 3 ]] && printusage -H >&2 && return 1

} 

parseArgs() {
#
#- Title:               parseArgs
#- Creation Date:       09-26-2015
#- Author:              jeanmichecote
#- Github:              EDIT HERE
#- Version:             1.0    
#   
#: Usage:               parseArgs [Options] <arguments>
#: Description:         Parses option flags and option arguments from plain 
#:                      arguments and tries making sense out of it all.
#:    
#: Options:                 
#:                 -h   Prints out this usage block
#:                 -c   Prints out this function's credentials
#:                 -a   Prints out all of the arguments entered
#:                 -o   Prints out all of the option flags entered
#:                 -O   Prints out all of the options's arguments entered
#:                 -z   Prints out each option flag with its respective
#:                      argument AND every single arguments. The whole thing.
#:        
#: Arguments:           
#:                 $1   Arguments as an array
#: 
#: (exemple):           parseArgs -o "${array[@]}"
#


  source ~/.functions

  # [[ "$#" -eq 0 ]] && printusage -H && return 1
  # "${@:1:$(($# - 1))}"
  local OPTIND
  declare -a opts optsArgs soloArgs
  flag=""

  while getopts ":achoOz" opt; do
    case $opt in
      h ) printusage -H && return 0               ;;
      c ) printusage -C && return 0               ;;
 [aoOz] ) 
          flag=""
          # Parses through options and arguments
          shift
          for arg in "${@}" ; do
            case $arg in
                # In case of a short option flag
                \-[a-zA-Z0-9])
                  # If precedent argument was an option flag as well
                  if [[ "$flag" == "o" ]]; then
                    msg_fail "A flag is missing it's description."
                    printusage -H >&2
                    return 1
                  fi
                    # ... if precedent argument wasn't an option flag, then it was a option's argument
                    opts=("${opts[@]}" "$arg")
                    flag="o"
                 ;;
                # In case of an single argument or and option's argument
                *)  
                  # If precedent argument was an option flag, then this is an option's argument
                  if [[ "$flag" == "o" ]]; then
                    optsArgs=("${optsArgs[@]}" "$arg")
                    flag="a"
                  # If not, then this is a single argument
                  else
                    soloArgs=("${soloArgs[@]}" "$arg")
                  fi
                ;;
            esac
          done

          case $opt in
            a)  for a in "${soloArgs[@]}"; do
                  echo "$a"
                done     
            ;;
            o)  for o in "${opts[@]}"; do
                  echo "$o"
                done
            ;;
            O)  for O in "${optsArgs[@]}"; do
                  echo "$O"
                done
            ;;
            z)  for (( i=0; i < ${#opts[@]}; i++ )); do
                  echo "${opts[$i]} ${optsArgs[$i]}"
                done
                for (( z=0; z < ${#soloArgs[@]}; z++ )); do
                  echo "${soloArgs[$z]}"
                done
            ;;
          esac  
        ;;  
      * ) printusage -H >&2 && return 1           ;;
    esac
  done
  shift $(( OPTIND - 1 ))
} 

printusage() {
#       
#- Title            printusage
#- Creation date    09-17-2015
#- Author           Jean Michel Cote
#- Github           https://github.com/jeanmichelcote/scripts/.functions
#- Version          1.0
#- 
#
#: Usage:           printusage [Options] <arguments>
#:                  
#: Description:     Formats the printing of every script's and function's
#:                  own usage and credentials block.
#: 
#: [Options]:   -h  Prints out own usage block as text.
#:              -H  Prints out parent's usage block as text.
#:              -c  Prints out own credentials as text.
#:              -C  Prints out parent's credentials as text.
#:              -t  Prints out a commented out template usage block
#:                  that takes
#:                            
#: <Arguments>:     Accepts 0 arguments.
#:  
#: (example):       printusage -h -c
#: 
#   

  local header thisusage thiscreds thisfunc callerFunc funcFile opt OPTIND

  thisfunc="${FUNCNAME[0]}"
  callerFunc="${FUNCNAME[1]}"
  funcFile="${BASH_SOURCE[0]}"
  # Sets own usage bloc for printing when directly called by shell.
  thisusage=$( grep -A 25 "${thisfunc}() {" "$funcFile" \
            | awk '/#: / { print }' )
  thiscreds=$( grep -A 9 "${thisfunc}() {" "$funcFile" \
            | awk '/#- / { print }' )
  # Sets parent's usage block for printing when called by a script
  if [[ "$0" != -* ]]; then
    parentusage=$( awk '/^#: /' "$0" )
    parentcreds=$( awk '/^#- /' "$0" )
  # Sets parent's usage block for printing when called by another function
  else 
    parentusage=$( grep -A 25 "${callerFunc}() {" "$funcFile" \
                | awk '/#: /{ print }' )
    parentcreds=$( grep -A 8 "${callerFunc}() {" "$funcFile" \
                | awk '/#- /{ print }' )    
  fi
  # Styles
  RED="\033[0;31m"
  NC="\033[0m" 

  [[ "$#" -eq 0 ]] && echo "${thisusage//#: /}" && return 1 

  while getopts ":hHcC" opt; do
    case $opt in
      h) echo "${thisusage//#: /}" && return 0    ;;
      H) echo "${parentusage//#: /}"              ;;
      c) echo "${thiscreds//#- /}" && return 0    ;;
      C) echo "${parentcreds//#- /}"              ;;
      *) echo "${thisusage//#: /}" >&2 && return 1    ;;
    esac
  done
  shift $(( OPTIND - 1 ))

}
 
usageblock() {
#   
#- Title            usageblock
#- Creation date    09-22-2015
#- Author           Jean Michel Cote
#- Github           https://github.com/jeanmichelcote/scripts/.functions
#- Version          1.0
#- 
#
#: Usage:           usageblock <arguments>
#:                  
#: Description:     Use to print commented out custom usage blocks within 
#:                  new functions.
#: 
#: [Options]:   -h  Prints out this usage block.
#:              -c  Prints out this function's credentials.
#:                             
#: <Arguments>:     Accepts as many arguments as needed.
#:                  If the  mother function or script accepts option flags, 
#:                  first enter the flag followed immediately by a space and 
#:                  then its description. 
#:                  For simple arguments, just append them after all the 
#:                  options/descriptions and separate them by a space.
#:  
#: (example):       usageblock mynewfunc "Use for this and that" -h "Help message"
#:                  -v Version "My first argument" "Second argument"
#: 
#  

  local usage flag name desc now OPTIND
  declare -a opts optsArgs soloArgs

  if [[ "$#" -eq 1 ]]; then
    while getopts ":hc" opt; do
      case $opt in
        h) printusage -H && return 0      ;;
        c) printusage -C && return 0      ;;
        *) printusage -H >&2 && return 1  ;;
      esac
    done
    shift $(( OPTIND - 1 ))
  fi

  [[ "$#" -eq 0 ]] || [[ "$1" == "-h" ]] && printusage -H >&2 && return 0 
  
  name="$1"; shift
  desc="$1"; shift
  read -ra opts     <<<$( parseArgs -o "$@" )
  read -ra optsArgs <<<$( parseArgs -O "$@" )
  read -ra soloArgs <<<$( parseArgs -a "$@" )
  now=$(date +%m-%d-%Y)
  flag=""
 
  # Formats the header
  local formatUs formatCreds header
  formatUs="#: %-15b %-4b %-7b\n"
  formatCreds="${formatUs//#:/#-}"
  header=$( printf "$formatUs" "Usage:" " " "$name [OPTIONS] <arguments>" )
  [[ "${#opts[@]}" -eq 0 ]]     && header="${header//[OPTIONS]/}"
  [[ "${#soloArgs[@]}" -eq 0 ]] && header="${header//<arguments>/}"

  # Prints credentials block
  echo "#"
  printf "$formatCreds" \
  "Name:" " " "$name" \
  "Creation Date:" " " "$now" \
  "Author:" " " "$USER" \
  "Github:" " " "https://github.com/jeanmichelcote/scripts/.functions" \
  "Version:" " " "1.0" 
  echo "#"

  # Prints usage block
  echo "$header"

  printf "$formatUs" "Description:" " " "$desc" 
  if [[ "${#opts[@]}" -ne 0  ]]; then
    printf "$formatUs" "Options:" " " ""
    if [[ ! "${opts[@]}" =~ "-h" ]]; then
      printf "$formatUs" " " "-h" "Prints out this usage block"
    fi
    if [[ ! "${opts[@]}" =~ "-c" ]]; then
      printf "$formatUs" " " "-c" "Prints out this function's credentials"
    fi
    for (( i=0; i<${#opts[@]}; i++ )); do
      printf "$formatUs" " " "${opts[$i]}" "${optsArgs[$i]}"
    done
  fi
  if [[ "${#soloArgs[@]}" -ne 0  ]]; then
    printf "$formatUs" "Arguments:" "" ""
    for (( i =0; i < ${#soloArgs[@]}; i++ )); do
      printf "$formatUs" " " "\$$(($i+1))" "${soloArgs[$i]}"
    done
  fi
  printf "#: \n$formatUs" "(exemple):" " " "$name ${opts[0]} \"${optsArgs[0]}\" ${opts[1]} \"${optsArgs[1]}\" \"${soloArgs[0]}\""

  echo "#"
 } 

funx() { 
#    
#- Title            funx
#- Creation date    09-17-2015
#- Author           Jean Michel Cote
#- Github           https://github.com/jeanmichelcote/scripts/.functions
#- Version          1.0
#- 
#
#: Usage:           funx <arguments>
#:                  
#: Description:     Without argument, it prints out a list of all the
#:                  functions known to the system. 
#:                  While if you supply the name of a function as argument,
#:                  it prints out the entire definition for that function.
#: 
#: [Options]:   -h  Prints out this usage block.
#:              -c  Prints out this function's credentials.
#:                            
#: <Arguments>:     Accepts 0 or 1 arguments.
#:              $1  Name of the function for which to print out definition.
#:  
#: (example):       funx printusage
#: 
#
  local OPTIND
  # Styles
  RED="\033[0;31m"
  NC="\033[0m" 

  [[ "$#" -gt 1 ]] && printusage -H && return 1
  
  while getopts ":hc" opt; do
    case $opt in
      h) printusage -H && return 0  ;;
      c) printusage -C && return 0  ;;
      *) printusage -H >&2 && return 1  ;;
    esac
  done
  shift $(( OPTIND - 1 ))

  [[ -z "$1" ]] && declare -F | awk '{ print $3 }' | grep -v [*rvm] || \
  declare -f "$1"
} 

function cd() { 
#    
#- Title            cd
#- Creation date    09-17-2015
#- Author           Jeeger
#- Github           https://github.com/jeeger/z
#- Version          ---
#- 
#
#: Usage:           cd <arguments>
#:                  
#: Description:     Hijacks the builtin cd command to make it embrace z's 
#:                  functionalities.
#: 
#: [Options]:       None
#:                            
#: <Arguments>:     Accepts 0 or 1 arguments.
#:                  0 arguments = cd in the home directory.
#:                  $1 = name of the directory to cd in, wherever it is.
#:  
#: (example):       cd mail
#: 
#

  # Go to home without arguments
  [ -z "$*" ] && builtin cd && ls -la && return
  # If directory exists, change to it
  [ -d "$*" ] && builtin cd "$*" && ls -la && return
  # Catch cd . and cd ..
  case "$*" in
      ..) builtin cd ..; return;;
      .) builtin cd .; return;;
  esac
  # Finally, call z.
  z "$*" 2>&1  || builtin cd "$*" && ls -la
} 

getServerProp() {
#    
#- Title            getServerProp
#- Creation date    09-17-2015
#- Author           Jeanmichel Cote
#- Github           https://github.com/jeanmichelcote/scripts/.functions
#- Version          1.0
#- 
#
#: Usage:           getServerProp <arguments>
#:                  
#: Description:     Return queried properties of an openstack server instance
#: 
#: [Options]:   -h  Prints out this usage block.
#:              -c  Prints out this function's credentials.
#:                            
#: <Arguments>:     Accepts 2 arguments.
#:              $1  Property queried [status|network].
#:              $2  Name of the server to connect to.
#:  
#: (example):       getServerProp status lola
#: 
#

  local prop srv serverProps OPTIND

  while getopts ":hc" opt; do
    case $opt in
      h) printusage -H && return 0        ;;
      c) printusage -C && return 0        ;;
      *) printusage -H >&2 && return 1    ;;
    esac
  done
  shift $(( OPTIND - 1 ))

  [[ "$#" -ne 2 ]] && printusage -H  >&2 && return 1
  prop="$1"
  srv="$2"
  serverProps=$(nova show "$srv")
  
  case "$prop" in
     "status" ) echo "$serverProps" | awk '/status/ { print $4 }'   ;;
    "network" ) echo "$serverProps" | awk '/network/ { print $7 }'  ;;
            * ) printusage -H  >&2 && return 1                      ;;
  esac

  # echo "$serverProps" | awk -v pat="$1" '$0 ~ pat {pat == "status" ? print $4 : print $7; }'
}

osdo() {
#    
#- Title            osdo
#- Creation date    09-17-2015
#- Author           Jeanmichel Cote
#- Github           https://github.com/jeanmichelcote/scripts/.functions
#- Version          1.0
#- 
#
#: Usage:           osdo <arguments>
#:                  
#: Description:     Use openstack API to connect to a dreamcompute instance
#: 
#: [Options]:   -h  Prints out this usage block.
#:              -c  Prints out this function's credentials.
#:                            
#: <Arguments>:     Accepts 2 arguments.
#:              $1  Command to run [start|stop|login].
#:              $2  Name of the target server.
#:              $3  (Optional) Path of openRCfile.
#:  
#: (example):       osdo start lola
#: 
#

  local cmds cmd server user openrcfile serverStatus OPTIND 

  while getopts ":hc" opt; do
    case $opt in
      h) printusage -H && return 0         ;;
      c) printusage -C && return 0         ;;
      *) printusage -H >&2 && return 1     ;;
    esac
  done
  shift $(( OPTIND - 1 ))

  cmds="^(start$|stop|login)"
  [[ ! $1 =~ $cmds ]] && printusage -H >&2 && return 1
  cmd="$1"
  server="$2"
  openrcfile="${3:-${HOME}/Downloads/dhc198704-openrc.sh}" # Optional arg
  serverStatus=""
  user="dhc-user"

  printAnim() {
    local msg char numOfSecs
    msg="${1:-"Loggin in"}"
    char="${2:-"."}"
    numOfSecs="${3:-5}"

    printf "%s" "$msg"
    for n in `seq 0 "$numOfSecs"`; do
      if [[ "$n" -lt "$numOfSecs" ]]; then
        printf "%s" "$char"
      else
        printf "%s\n\n========================================================================\n\n"
      fi
      sleep 1
    done
  }

  # Load the OpenStack environment variables
  [[ -z "$OS_AUTH_URL" ]] && source "$openrcfile"

  case $cmd in
    "start" ) 
              # Make sure the server isnt't active yet before starting it 
              serverStatus=$( getServerProp status "$server")   
              [[ "$serverStatus" != "ACTIVE" ]] && nova start "$server" # Takes a while to boot up
              until [[ "$serverStatus" == "ACTIVE" ]]; do
                serverStatus=$( getServerProp status "$server")
              done
              msg_success "${server} server is now ACTIVE"
              printAnim "Logging in" "." 5
              nova ssh "$server" --login "$user"
            ;;
    "login" )
              nova ssh "$server" --login "$user"
              printAnim
            ;;
    "stop"  )
              nova stop "$server"
              until [[ "$serverStatus" == "SHUTOFF" ]]; do
                serverStatus=$( getServerProp status "$server")
                printf "%s" "."
              done
              echo
              msg_notice "${server} is now shutdown"
            ;;
  esac
}

getTotal() {
#    
#- Title            getTotal
#- Creation date    09-17-2015
#- Author           Jeanmichel Cote
#- Github           https://github.com/jeanmichelcote/scripts/.functions
#- Version          1.0
#- 
#
#: Usage:           getTotal <arguments>
#:                  
#: Description:     Get the combined totals on my work invoices 
#: 
#: [Options]:   -h  Prints out this usage block.
#:              -c  Prints out this function's credentials.
#:              -r  Uses pdfgrep recursive search for directories
#:                            
#: <Arguments>:     None
#:  
#: (example):       getTotal -r
#: 
#
  
  local totals sum sansdec OPTIND
  
  while getopts ":hcr" opt; do
    case $opt in
      h) printusage -H && return 0              ;;
      c) printusage -C && return 0              ;;
      r) totals=$( pdfgrep -h -r Total )        ;;
      *) printusage -H >&2 && return 1          ;;
    esac
  done
  shift $(( OPTIND - 1 ))

  # Get a list of total amounts of $$$.$$ 
  # Either recursively searching directories or only current directory
  totals="${totals:-$( pdfgrep -h Total *.pdf )}"

  # Get rid of every character that is not a digit
  totals=$( echo "$totals" | sed 's/[^0-9]*//g' )

  # Sum up the amounts
  sum=0
  for n in $totals; do
    sum=$(($sum+$n))
  done

  # Puts back the comas at each thousand, the dot at decimals and the $ sign in
  sansdec=(${#sum}-2)
  sum="${sum:0:$sansdec}.${sum: -2}"
  printf "%s" "\$"
  printf "%'.2f\n" "$sum"
} 

# Gets all the hidden files or directories in current or selected path
getdotfiles() {
    local usage="Usage:\n
                Accepts two (2) arguments.\n
                \$1 = \"f\" for hidden files OR \"d\" for hidden directories\n
                \$2 = Path to search. If no path is specified, current directory is used\n"
    
    [[ "$#" -gt 2 ]] || [[ "$1" =~ "-h" ]] && echo -e $usage && return 1 
    
    local typ=""  # f for files, d for directories
    local dir=$(pwd)

    case $# in
        0)                                                    ;;
        1)  [[ "$1" =~ [fd] ]] && typ="-type $1" || dir="$1"  ;;
        2)  typ="-type $1" && dir="$2"                        ;;
        *)  echo -e "$usage" && return 1                      ;;
    esac

    printf "%s\n" "$( find $dir -maxdepth 1 $typ -name '.*' -exec basename {} \; )"
    unset usage typ dir
}
# getDotFiles() {
# #    
# #- Title            getDotFiles
# #- Creation date    09-17-2015
# #- Author           Jeanmichel Cote
# #- Github           https://github.com/jeanmichelcote/scripts/.functions
# #- Version          1.0
# #- 
# #
# #: Usage:           getDotFiles [Options] <Arguments>
# #:                  
# #: Description:     Gets either all the hidden files, either all directories or fetch them all
# #:                  in current or selected path 
# #: 
# #: [Options]:   
# #:              -h  Prints out this usage block.
# #:              -c  Prints out this function's credentials.
# #:              -f  Gets hidden files
# #:              -d  Gets hidden directory
# #:                  No options prints out all hidden files and directories
# #:              
# #: <Arguments>: 
# #:              $1  Path to search. If no path is specified, current directory is used"
# #:  
# #: (example):       getDotFiles -f
# #: 
# #
# 
#   while getopts ":hcfd" opt; do
#     case $opt in
#       h) printusage -H && return 0              ;;
#       c) printusage -C && return 0              ;;
#       f) totals=       
#       ;;
#       d)
#       ;;
#       *) printusage -H >&2 && return 1          ;;
#     esac
#   done
#   shift $(( OPTIND - 1 ))
# 
#     [[ "$#" -gt 2 ]] || [[ "$1" =~ "-h" ]] && echo -e $usage && return 1 
#     
#     local typ=""  # f for files, d for directories
#     local dir=$(pwd)
# 
#     case $# in
#         0)                                                    ;;
#         1)  [[ "$1" =~ [fd] ]] && typ="-type $1" || dir="$1"  ;;
#         2)  typ="-type $1" && dir="$2"                        ;;
#         *)  echo -e "$usage" && return 1                      ;;
#     esac
# 
#     printf "%s\n" "$( find $dir -maxdepth 1 $typ -name '.*' -exec basename {} \; )"
#     unset usage typ dir
# }

# Extract any kind of archived file
#    cd "$2" 
extract() {
  if [ -z "$1" ]; then
    # display usage if no parameters given
    echo "Usage: extract <path/file_name>.<zip|rar|bz2|gz|tar|tbz2|tgz|Z|7z|xz|ex|tar.bz2|tar.gz|tar.xz>"
  else
    if [ -f "${1}" ]; then
      # NAME="${{}"1%.*}
      # mkdir "${N}"AME && cd "${N}"AME
      case "${1}" in
        *.tar.bz2)   tar xvjf ../"${1}"    ;;
        *.tar.gz)    tar xvzf ../"${1}"    ;;
        *.tar.xz)    tar xvJf ../"${1}"    ;;
        *.lzma)      unlzma ../"${1}"      ;;
        *.bz2)       bunzip2 ../"${1}"     ;;
        *.rar)       unrar x -ad ../"${1}" ;;
        *.gz)        gunzip ../"${1}"      ;;
        *.tar)       tar xvf ../"${1}"     ;;
        *.tbz2)      tar xvjf ../"${1}"    ;;
        *.tgz)       tar xvzf ../"${1}"    ;;
        *.zip)       unzip ../"${1}"       ;;
        *.Z)         uncompress ../"${1}"  ;;
        *.7z)        7z x ../"${1}"        ;;
        *.xz)        unxz ../"${1}"        ;;
        *.exe)       cabextract ../"${1}"  ;;
        *)           echo "extract: ${1} - unknown archive method" ;;
      esac
    else
        echo "${1} - file does not exist" >&2
    fi
  fi
}

# Use to make sure any prompted entry is validated and sanitized. 
sanitize() { 
    string=$1 
    clean=${string//[^a-zA-Z0-9[:space:]-/_/]}
    # Styles
    RED="\033[0;31m"
    NC="\033[0m" # No Color


    if [[ "$string" == "$clean" ]]; then
        echo "$clean"
    else
      echo "$clean"
      msg_error "Contains invalid characters. Alpha-numeric values and spaces only."
    fi
} 

# Displays a bash color table with ready-to-copy escape codes.
colors() {
  local fgc bgc vals seq0

  printf "Color escapes are %s\n" '\e[${value};...;${value}m'
  printf "Values 30..37 are \e[33mforeground colors\e[m\n"
  printf "Values 40..47 are \e[43mbackground colors\e[m\n"
  printf "Value  1 gives a  \e[1mbold-faced look\e[m\n\n"

  # foreground colors
  for fgc in {30..37}; do
    # background colors
    for bgc in {40..47}; do
      fgc=${fgc#37} # white
      bgc=${bgc#40} # black

      vals="${fgc:+$fgc;}${bgc}"
      vals=${vals%%;}

      seq0="${vals:+\e[${vals}m}"
      printf "  %-9s" "${seq0:-(default)}"
      seq1="$seq0"
      printf " ${seq0}YO\e[m"
      #printf " \e[${vals:+${vals+$vals;}}1mBOLD\e[m"
    done
    echo; echo
  done
}

# Encryption / decryption
encrypt() {
  # $1 = file name without the extension
  openssl des3 -salt -in "${1}.${2}" -out "${1}.des3"
}

decrypt() {
        local pswd
  # $1 = file name without extension
  # $2 = password
        read -s -p "Enter password:" pswd; echo
  openssl des3 -d -salt -in "${1}.des3" -out "${1}.${2}" -k "$pswd"
        unset pswd
}

# animated gifs from any video
# from alex sexton   gist.github.com/SlexAxton/4989674
gifify() {
  if [[ -n "$1" ]]; then
    if [[ $2 == '--good' ]]; then
      ffmpeg -i $1 -r 10 -vcodec png out-static-%05d.png
      time convert -verbose +dither -layers Optimize -resize 900x900\> out-static*.png  GIF:- | gifsicle --colors 128 --delay=5 --loop --optimize=3 --multifile - > $1.gif
      rm out-static*.png
    else
      ffmpeg -i $1 -s 600x400 -pix_fmt rgb24 -r 10 -f gif - | gifsicle --optimize=3 --delay=3 > $1.gif
    fi
  else
    echo "proper usage: gifify <input_movie.mov>. You DO need to include extension."
  fi
}

# Create a new directory and enter it
mkd() {
  mkdir -p "$@" && cd "$@"
}

# Create a .tar.gz archive, using `zopfli`, `pigz` or `gzip` for compression
targz() {
  local tmpFile="${@%/}.tar"
  tar -cvf "${tmpFile}" --exclude=".DS_Store" "${@}" || return 1

  size=$(
    stat -f"%z" "${tmpFile}" 2> /dev/null; # OS X `stat`
    stat -c"%s" "${tmpFile}" 2> /dev/null # GNU `stat`
  )

  local cmd=""
  if (( size < 52428800 )) && hash zopfli 2> /dev/null; then
    # the .tar file is smaller than 50 MB and Zopfli is available; use it
    cmd="zopfli"
  else
    if hash pigz 2> /dev/null; then
      cmd="pigz"
    else
      cmd="gzip"
    fi
  fi

  echo "Compressing .tar using \`${cmd}\`…"
  "${cmd}" -v "${tmpFile}" || return 1
  [ -f "${tmpFile}" ] && rm "${tmpFile}"
  echo "${tmpFile}.gz created successfully."
}

# Determine size of a file or total size of a directory
fs() {
  if du -b /dev/null > /dev/null 2>&1; then
    local arg=-sbh
  else
    local arg=-sh
  fi
  if [[ -n "$@" ]]; then
    du $arg -- "$@"
  else
    du $arg .[^.]* *
  fi
}

# Use Git’s colored diff when available
hash git &>/dev/null
if [ $? -eq 0 ]; then
  diff() {
    git diff --no-index --color-words "$@"
  }
fi

# Create a data URL from a file
dataurl() {
  local mimeType=$(file -b --mime-type "$1")
  if [[ $mimeType == text/* ]]; then
    mimeType="${mimeType};charset=utf-8"
  fi
  echo "data:${mimeType};base64,$(openssl base64 -in "$1" | tr -d '\n')"
}

# Create a git.io short URL
gitio() {
  if [ -z "${1}" -o -z "${2}" ]; then
    echo "Usage: \`gitio slug url\`"
    return 1
  fi
  curl -i http://git.io/ -F "url=${2}" -F "code=${1}"
}

# Start an HTTP server from a directory, optionally specifying the port
server() {
  local port="${1:-8000}"
  sleep 1 && open "http://localhost:${port}/" &
  # Set the default Content-Type to `text/plain` instead of `application/octet-stream`
  # And serve everything as UTF-8 (although not technically correct, this doesn’t break anything for binary files)
  python -c $'import SimpleHTTPServer;\nmap = SimpleHTTPServer.SimpleHTTPRequestHandler.extensions_map;\nmap[""] = "text/plain";\nfor key, value in map.items():\n\tmap[key] = value + ";charset=UTF-8";\nSimpleHTTPServer.test();' "$port"
}

# Start a PHP server from a directory, optionally specifying the port
# (Requires PHP 5.4.0+.)
phpserver() {
  local port="${1:-4000}"
  local ip=$(ipconfig getifaddr en1)
  sleep 1 && open "http://${ip}:${port}/" &
  php -S "${ip}:${port}"
}

# Compare original and gzipped file size
gz() {
  local origsize=$(wc -c < "$1")
  local gzipsize=$(gzip -c "$1" | wc -c)
  local ratio=$(echo "$gzipsize * 100/ $origsize" | bc -l)
  printf "orig: %d bytes\n" "$origsize"
  printf "gzip: %d bytes (%2.2f%%)\n" "$gzipsize" "$ratio"
}

# Escape UTF-8 characters into their 3-byte format
escape() {
  printf "\\\x%s" $(printf "$@" | xxd -p -c1 -u)
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    echo # newline
  fi
}

# Decode \x{ABCD}-style Unicode escape sequences
unidecode() {
  perl -e "binmode(STDOUT, ':utf8'); print \"$@\""
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    echo # newline
  fi
}

# Get a character’s Unicode code point
codepoint() {
  perl -e "use utf8; print sprintf('U+%04X', ord(\"$@\"))"
  # print a newline unless we’re piping the output to another program
  if [ -t 1 ]; then
    echo # newline
  fi
}

# Show all the names (CNs and SANs) listed in the SSL certificate
# for a given domain
getcertnames() {
  if [ -z "${1}" ]; then
    echo "ERROR: No domain specified."
    return 1
  fi

  local domain="${1}"
  echo "Testing ${domain}…"
  echo # newline

  local tmp=$(echo -e "GET / HTTP/1.0\nEOT" \
    | openssl s_client -connect "${domain}:443" 2>&1);

  if [[ "${tmp}" = *"-----BEGIN CERTIFICATE-----"* ]]; then
    local certText=$(echo "${tmp}" \
      | openssl x509 -text -certopt "no_header, no_serial, no_version, \
      no_signame, no_validity, no_issuer, no_pubkey, no_sigdump, no_aux");
      echo "Common Name:"
      echo # newline
      echo "${certText}" | grep "Subject:" | sed -e "s/^.*CN=//";
      echo # newline
      echo "Subject Alternative Name(s):"
      echo # newline
      echo "${certText}" | grep -A 1 "Subject Alternative Name:" \
        | sed -e "2s/DNS://g" -e "s/ //g" | tr "," "\n" | tail -n +2
      return 0
  else
    echo "ERROR: Certificate not found.";
    return 1
  fi
}


# Install Grunt plugins and add them as `devDependencies` to `package.json`
# Usage: `gi contrib-watch contrib-uglify zopfli`
gi() {
  local IFS=,
  eval npm install --save-dev grunt-{"$*"}
}

# `tw` with no arguments opens the current directory in TextWrangler, otherwise
# opens the given location
tw() {
  if [ $# -eq 0 ]; then
    edit -b com.barebones.textwrangler -n  .
  else
    edit -b com.barebones.textwrangler -n "$@"
  fi
}

# `m` with no arguments opens the current directory in TextMate, otherwise
# opens the given location
m() {
  if [ $# -eq 0 ]; then
    mate .
  else
    mate "$@"
  fi
}

# `s` with no arguments opens the current directory in Sublime Text, otherwise
# opens the given location
s() {
  if [ $# -eq 0 ]; then
    subl .
  else
    subl "$@"
  fi
}

# `o` with no arguments opens current directory, otherwise opens the given
# location
o() {
  if [ $# -eq 0 ]; then
    open .
  else
    open "$@"
  fi
}

#find and list processes matching a case-insensitive partial-match string
fp() { 
    ps Ao pid,comm | awk '{match($0,/[^\/]+$/); print substr($0,RSTART,RLENGTH)": "$1}'|grep -i $1|grep -v grep
}

# build menu to kill process
fk() { 
    IFS=$'\n'
    PS3='Kill which process? '
    select OPT in $(fp $1) "Cancel"; do
        if [ $OPT != "Cancel" ]; then
            kill $(echo $OPT|awk '{print $NF}')
        fi
        break
    done
    unset IFS
}

getrealpath() {

    [[ ! -f "$1" ]] && echo "File does not exist" && return 1 # failure : file does not exist.
    [[ -n "$no_symlinks" ]] && local pwdp='pwd -P' || local pwdp='pwd' # do symlinks.
    echo "$( cd "$( echo "${1%/*}" )" 2>/dev/null; $pwdp )"/"${1##*/}" # echo result.
    return 0 # success

}

# Accessing a headless VM server on virtualbox via SSH
vm() {

  ################ Customize those variables ################
  local vm="Ubuntu Server 12.04.4 LTS"
  local vbox="VBoxHeadless"
  local useropt1="jeanmichel"
  local useropt2="deployer"
  ##########################################################
  
  local process=$( ps ax | grep $vbox | grep -v grep | wc -l )
  local usage="{ st to start | ss to savestate | sd to shutdown | stat to get the status }"

  case $1 in
    st) 
      # Start the server case
      # First, lets determine which user logs in
      if [ ! $2 ]
      then
        PS3='User?'
        echo "Log in as:"
        select u in $useropt1 $useropt2; do
          if [[ -n $u ]]; then
                user=$u; break;
            else
              print 'invalid'
            fi
        done
      fi
      
      # Then, checks if the server is already running
      if [ $process != 0 ] 
      then  
        echo -e "Virtal machine already running.\nRelogging in as" $user"..."
        ssh -p 3022 $user@127.0.0.1
      else
        # If not, start the server and log in with the right user
        VBoxManage startvm "$vm" --type headless
        echo "Waiting for boot up..."   
        echo "Logging in as" $user"..."
        ssh -p 3022 $user@127.0.0.1
      fi
      ;;
    ss)
      # Savestate the server case
      # Checks if the server is already down
      if [ $process == 0 ]
      then
        echo "All virtual machines are already down"
      else
        VBoxManage controlvm "$vm" savestate
        echo "Just savestated and stopped" $vm
      fi
      ;;
    sd)
      # Graceful shutdown case
      # Checks if the server is already down
      if [ $process == 0 ] 
      then
        echo "All virtual machines are already down"
      else
        VBoxManage controlvm "$vm" acpipowerbutton
        echo "Just gracefully shut down "${vm}""
      fi
      ;;
    stat)
      # Status check case
      if [ $process != 0 ] 
      then
        echo -e "\nHere are the processes running:\n"
        echo -e "---------------------------------\n"
        ps -Af|grep $vbox | grep -v grep
        echo -e "---------------------------------\n"       
      else
        echo -e "\nNo virual machines are running at the moment.\n"
      fi
      ;;
    *)
      echo $usage
      ;;
  esac
}

# Mount an iso file
mountit() { 
    ################ Customize those variables ################
    mountpoint="/mnt/disk"
    usage="\nSearches through current directory for .iso files.\n
        IF an argument is specefied, it should be a full path leading to them.\n\nUSAGE\n-m to mount | -u to unmount\n"
    local intheloop
        ##########################################################
      
    while getopts ":mu" opt; do 
        case $opt in
            u)  echo -e "Unmounting $mountpoint"
                sudo umount "$mountpoint"
                ;;
        
            m)  # If one or more arguments are found, only the first one will slip in. 
                # If none, the current directory will do.
                shift
                searchpath=$( [[ "$#" -ge 1 ]] && echo "${1%/}" || echo "./")
        
                # Fill an array with .iso files crossed in the $searchpath
                unset isofiles
                declare -a isofiles
                isofiles+=("${searchpath}/*.iso")           # Put the / back in   
        
                if [[ "$isofiles" ]]; then
                    PS3='----->'
                    echo "Choose an .iso file to mount:"
                    select item in ${isofiles[@]##*/}; do   # Strip the full path
                        if [[ -n $item ]]; then
                            isofile=$item; break;
                        else
                            print "Invalid"
                        fi
                    done
                else
                    echo "No .iso files has been found in the directory"
                fi
                mount -o loop "${searchpath}/{$isofile}" $mountPoint  # Put the full path back in
                cd $mountpoint; ls -la
                ;;
        
            *)  echo -e $usage
                ;;
        esac
        shift $((OPTIND-1))
        intheloop=true
    done
  
    [[ -n "$intheloop" ]] && echo -e $usage
}

###########################################################
## MAC OSX STUFF ##

# Change working directory to the top-most Finder window location
cdf() { # short for `cdfinder`
  cd "$(osascript -e 'tell app "Finder" to POSIX path of (insertion location as alias)')"
}

# Add note to Notes.app (OS X 10.8)
# Usage: `note 'title' 'body'` or `echo 'body' | note`
# Title is optional
note() {
  local title
  local body
  if [ -t 0 ]; then
    title="$1"
    body="$2"
  else
    title=$(cat)
  fi
  osascript >/dev/null <<EOF
tell application "Notes"
  tell account "iCloud"
    tell folder "Notes"
      make new note with properties {name:"$title", body:"$title" & "<br><br>" & "$body"}
    end tell
  end tell
end tell
EOF
}

# Manually remove a downloaded app or file from the quarantine
unquarantine() {
  for attribute in com.apple.metadata:kMDItemDownloadedDate com.apple.metadata:kMDItemWhereFroms com.apple.quarantine; do
    xattr -r -d "$attribute" "$@"
  done
}

# Add reminder to Reminders.app (OS X 10.8)
# Usage: `remind 'foo'` or `echo 'foo' | remind`
remind() {
  local text
  if [ -t 0 ]; then
    text="$1" # argument
  else
    text=$(cat) # pipe
  fi
  osascript >/dev/null <<EOF
tell application "Reminders"
  tell the default list
    make new reminder with properties {name:"$text"}
  end tell
end tell
EOF
}


killhttpd() {
  sudo killall httpd
  sudo launchctl unload /System/Library/LaunchDaemons/org.apache.httpd.plist
}

## END MAC OSX STUFF ##.
###########################################################

ini
